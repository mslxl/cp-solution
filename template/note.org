#+LATEX_CLASS: org-ctex
#+TITLE: 算法笔记和板子
#+OPTIONS: _:nil
#+OPTIONS: ^:nil

* STL
** stack 栈
*** =template <class T, class Container = deque<T> >=
+ T :: 元素类型
+ Container :: 使用的容器，必须支持 =empty=, =size=, =back=, =push\under{}back=, =pop\under{}back=, =back= 。 =vector=, =deque= 和 =list= 都满足要求
*** 操作
+ push() ::
+ pop() ::
+ top() -> T ::
+ empty() -> bool ::
  + size() -> size\under{}t ::

注意：当 empty()->true 时， pop() 和 top() 会 RE

没有 clear() 操作，需要清空时可以循环出栈，也可以重新创建一个栈
不支持迭代器！
** vector 动态数组
*** 构造器
+ ()  ::
+ (size\under{}t) :: 指定初始 vector 容量
+ (size\under{}t, T) :: 初始值为 size_t 个 T
+ (vector&) :: 浅拷贝
+ (iter\under{}begin, iter\under{}end) :: 浅拷贝
+ (init\under{}list) :: 初始化列表
*** 操作
+ begin() -> riter ::
+ end() -> riter ::
+ back() -> T ::
+ front() -> T ::
+ operator string[](size\under{}t) -> T ::
+ push\under{}back(T) ::
+ pop\under{}back() -> T ::
+ empty() -> bool ::
+ size() -> size\under{}t ::
*** 经典应用
**** 邻接表
#+begin_src cpp :results none
struct edge{
    int from,to;
    int value;
};
const int maxn = 1e5 + 5;
vector<edge> map[maxn];
#+end_src

** set 集合
*** template <class T, class Compare = less<T>, class Alloc = allocator<T>>
+ T :: 元素类型
+ Compare :: 比较器，除了从小到大 =less<T>= 之外还可以用 =greater<T>=
+ Allow :: 内存分配器
  用堆实现，能在 log^n 的时间复杂度内实现更新查询
*** 操作
+ clear() ::
+ insert(T) ::
+ count(T) -> size\under{}t :: 由于集合的性质， =count= 只会返回 0 或 1, 可以用他判断元素是否存在
+ find(T) -> iter :: 查找元素，找不到 =iter= 就与 =end()= 相同
+ size() -> size\under{}t ::
+ earse(T) :: 删除元素 T
+ begin() -> biter :: 返回的是双向迭代器，不支持随机访问
+ end() -> biter :: 返回的是双向迭代器，不支持随机访问
*** 主要应用
去重，排序

** priority_queue 优先队列
*** template <class T, class Container = std::vector<T>, class Compare = std::less<typename Container::value_type>> class priority_queue;
+ T :: 元素类型
+ Container :: 使用的容器
+ Compare :: 比较器，除了从小到大 =less<T>= 之外还可以用 =greater<T>=, 或者重载 =bool operator ()=

** string 字符串

不能说很难用，只能说十分难用 +那也比没有好+

*** 操作
+ length() -> size\under{}t ::
+ size() -> size\under{}t ::
+ operator string +, += ::
+ operator string <, <=, ==, !=, >=, > ::
+ substr(size\under{}t begin) -> str ::
+ substr(size\under{}t begin, size\under{}t len) -> str ::
+ insert(size\under{}t pos, char[]) -> str& :: 在 =pos= 位置插入 =char[]= , 原位置的字符顺势后延
+ insert(size\under{}t pos, size\under{}t len, char[]) -> str& :: 在 =pos= 位置插入 =len= 个 =char=, 原位置的字符顺势后延
+ easer(size\under{}t begin) -> str& ::
+ easer(size\under{}t begin, size\under{}t end) -> str& ::
+ c\under{}str() -> char* ::
+ swap(str&) ::
+ find(str, pos) ::
+ find(str) ::

** map 键值对

*** template < class Key, class T, class Compare = less<Key>, class Alloc = allocator<pair<const Key, T> >
+ Key :: 建类型
+ T :: 值类型
+ Compare :: 比较器，需要 Key 实现对应的方法（默认 =less<Key= 需要实现 =operator bool<= ）

*** 操作
+ count(Key) -> size\under{}t ::
+ find(Key) -> iter ::
+ earse(Key) -> size\under{}t :: 返回删除元素的个数
+ earse(iter) ::
+ insert(pair<Key,T>) :: 由于 =map= 内部的 =key= 结构是 =insert=, 古行为与 =set= 一致，即当 =key= 已存在时，不进行任何操作
+ operator T& [Key] ::

** algorithm 算法头
*** sort(begin\under{}iter, end\under{}iter)
*** reverse(begin\under{}iter, end\under{}iter)
*** next\under{}permutation(begin\under{}iter, end\under{}iter) -> bool
进行下一次全排列，当已经没有下一个排列后返回 =false= （即达到最大字典序） 。
*注意：在使用该函数前请先对数据进行 =sort= 操作*
**** 算法

从最右边开始，两两比较相邻的元素，直到找到右边比左边大的一对，左边那个就是将要被替换的。再从最右边开始找比这个元素大的第一个，交换这两个。
交换之后，翻转交换元素后面的所有元素

例如：
#+begin_src dot :file ./figure/dot/next_permutation.png
digraph G {
  rankdir = "LR";
  st[label = "1 3 [4 6] 5 2" ];
  nd[label = "1 3 [5] 6 [4] 2"];
  rd[label = "1 3 5 [2 4 6]"]
  st -> nd [label = "从右侧找到比 4 打的数 5, 交换"];
  nd -> rd [label = "翻转左边交换后面的所有元素(reverse)"];
}
#+end_src

#+RESULTS:
[[file:./figure/dot/next_permutation.png]]
*** prev\under{}permutation(begin\under{}iter, end\under{}iter) -> bool
*** 不能用的函数
+ unique :: c++17 引入第一版，11 上没有

* 结构与算法
** 快读

+随手写的，有时间优化下+

#+begin_src cpp
template <typename T> T rd() {
  T num = 0;
  bool flag = false;
  char c;
  while ((c = getchar()) && c != '-' && !std::isdigit(c));
  if (c == '-')
    flag = true;
   else
    num += c - '0';
  while ((c = getchar()) && std::isdigit(c))
    num = 10 * num + c-'0';
  return flag ? -num : num;
}
#+end_src

** 快速幂

#+begin_src cpp
template <typename T> T pow(T a, T b) {
  T ans = 1;
  for (; b; b >>= 1LL) {
    if (b & 1)
      ans = ans * a;
    a = a * a;
  }
  return ans;
}

#include <iostream>
int main() { std::cout << pow(2ULL, 50ULL) << std::endl; }
#+end_src

#+RESULTS: :wrap src text
: 1125899906842624

** 离散化

保留原有数据的相对关系，缩小数据范围

可以采用排序来解决
#+begin_src cpp :exports both :results output
#include <algorithm>
#include <cstdio>
#include <vector>
struct Element {
  int v;
  int in_order;
  bool operator<(const Element &rhs) const { return this->v < rhs.v; }
};
void print_arr(int *arr, int len) {
  for (int i = 0; i < len; i++) {
    printf("%d ", arr[i]);
  }
  printf("\n");
}
int main() {
  int data[] = {54432, 11, 3434, 233, 11};
  printf("Before: ");
  print_arr(data, 5);

  std::vector<Element> list;
  for (int i = 0; i < 5; i++) {
    // 实际操作可读入时便构造结构体
    list.push_back(Element{data[i], i});
  }
  // 排序是重中之重
  std::sort(list.begin(), list.end());
  for (int i = 0, count = 1; i < list.size(); i++) {
    if (i > 0 && list[i].v != list[i - 1].v) {
      count++;
    }
    data[list[i].in_order] = count;
  }

  printf("After: ");
  print_arr(data, 5);
  return 0;
}
#+end_src
** 贪心
*** 选择不相交区间问题

经典例题：[[https://www.luogu.com.cn/problem/P1803][P1803]]
放置右端点靠左的线段，从左往右放，右端点越靠左妨碍越少
#+INCLUDE: ../oj/luogu/P1803.cpp src cpp
** 树

前序遍历：$PreOrder(T) = Root(T) + PreOrder(Left(T)) + PreOrder(Right(T))$

中序遍历：$InOrder(T) =  InOrder(Left(T)) + Root(T) + InOrder(Right(T))$

后序遍历：$PostOrder(T) = PostOrder(Left(T)) + PostOrder(Right(T)) + Root(T)$

*** 构造
根据后序遍历找到树根，然后在中序遍历中找到树根，从而找到左右子树的节点列表，然后递归构造左右子树。

#+INCLUDE: ../oj/uva/uva548.cpp src cpp

** 图

#+begin_src dot :file ./figure/dot/simple_g.png
digraph{
  rankdir = "LR";
  2 -> 1;
  3 -> 1;
  3 -> 4 -> 2;
}
#+end_src

#+RESULTS:
[[file:./figure/dot/simple_g.png]]

+ 前驱 :: 有向图中指向某个节点的上一个节点，例如上图中 =1= 的前驱有 =2= 和 =3=
+ 度 :: 某个节点所临近的边，例如 =3= 的度为 2，分别是 =3->1= 和 =3->4=
+ 入度 :: 指向该节点的边的数量，例如 =1= 的入度为 2, =2= 的入度为 1
*** 拓扑排序


拓扑排序是指将一个 *有向无环* 图 G 的所有项排成一个线性结构，使得有向无环图 G 的边集中的任意一条边 <u, v> 始终满足 u 出现在 v 前面

通常这样的序列成为拓扑序列，拓扑序列经常不唯一

基本思想：

#+begin_src dot :file ./figure/dot/mind_topo.png
digraph{
  rankdir = "LR";
  st[label="在 DAG 中找到一个没有前驱的节点（即入度为0的节点），输出"];
  nd[label="在图中删除该节点，并删除以该节点为尾的弧"];
  Start -> st;
  st -> nd;
  nd -> st[label="存在未被删除的节点"];
  nd -> End[label="所有节点都被删除"]
}

#+end_src

#+RESULTS:
[[file:./figure/dot/mind_topo.png]]


+这其实是一种 DAG DP+

**** BFS

#+begin_src cpp
//采用vector存图(G是图)
inline int topo(void) {
  queue<int> q; //入度为0节点的队列
  int ans[MAXN], tot = 0;
  // in数组为每个节点的入度
  for (register int i = 1; i <= n; i++)
    if (in[i] == 0)
      q.push(i);
  while (!q.empty()) {
    register int t = q.front();
    q.pop();
    ans[++tot] = t; //记录答案
                    //干掉它
    for (register int i = 0; i < G[t].size(); i++) {
      in[G[t][i]]--;
      if (in[G[t][i]] == 0)
        q.push(G[t][i]);
    }
  }
  return tot == n;
}
#+end_src

如果要求拓扑排序时遵从字典序，可以考虑 =priority_queue=

**** DFS

可以借助 DFS 完成拓扑排序，在访问完一个节点后把它加到当前拓扑的首部。 *不是尾部*


以 UVA10305 为例题 [[https://www.luogu.com.cn/problem/UVA10305][Ordering Tasks - 洛谷]]。

#+INCLUDE: ../oj/uva/uva10305.cpp src cpp

*** 最短路问题
**** Dijkstra

[[https://www.bilibili.com/video/BV1zz4y1m7Nq][B 站讲解]]

总结可以分为两步
1. 每次从未标记的节点中选择距离出发点最近的节点，标记，收录到最优路径集合中
2. 计算刚加入节点 A 的邻近节点 B 的路径 (不包含标记的节点), 若节点到起点的长度小于已存储的距离，就更新该节点
***** 例题
#+INCLUDE: ../oj/luogu/P3371.cpp src cpp

*** 欧拉回路/道路

也就是平时所说的一笔划问题

在欧拉道路中，除了起点和终点外，其他点的度数应该是偶数。
如果不存在奇点，那么一定存在 *欧拉回路*

对于有向图：最多只能有两个点的入度不等于出度，而且必须其中 *一个点的出度比入度大 1(作为起点)* 另一个 *入度比出度大 1(作为终点)*.

根据联通性可以判断出无向图和有向图是否存在欧拉道路和欧拉回路。可以用 DFS 构造欧拉回路和欧拉道路。

下面程序同时适用于欧拉回路和欧拉道路，但是如果是欧拉道路时，调用的参数必须是道路起点。另外， *打印顺序是逆序的* ，可以用一个 =stack= 先存起来。

#+begin_src cpp
void euler(int u){
    for(int v = 0; v < n; v++){
        if(G[u][v] && !vis[u][v]){
            vis[u][v] = vis[v][u] = 1;
            euler(v);
            printf("%d <- %d", u, v);
        }
    }
}
#+end_src

上述代码仅适用于无向图，如果改为有向图，需要吧 =vis[u][v] = vis[v][u] = 1= 改为 =vis[u][v]= 即可。

*** 并查集


判断是否有环

B 站讲解：[[https://www.bilibili.com/video/BV13t411v7Fs][【算法】并查集（Disjoint Set]]

[[https://www.luogu.com.cn/problem/P3367][【模板】并查集]]:

#+INCLUDE: ../oj/luogu/P3367.cpp src cpp

** 维护区间

*** 树状数组

如果在统计过程中存在中间操作，则树状数组不可用，请使用线段树
#+INCLUDE: ./binary_indexed_tree.cpp src cpp
*** 线段树

利用线段树计算的公式必须满足结合律！e.g. $a + b + c + d = a + (b+c)+d$

用数组实现时一般开 4 倍节点空间（也有不够的时候）

*注意！当线段树无 lazy 标签时，下传一定要传到最后一个子节点，否则在区间操作时会 WA 掉*
lazy 标签的存在正是为了减少下传次数。
即
#+NAME: 无 lazy 的线段树 update
#+begin_src cpp :exports code
void update(int start, int end){
    if(end < left || right < start){
        // 出界，无更新直接返回
        return;
    }
    if (left == right){
        // 一定要更新到最后一个节点
        tree[node] = val
    }else{
        int mid = left + (right - left) / 2;
        if(start <= mid){
            left_node.update(start, end);
        }
        // 不是 else if 逻辑，因为更新区间可能跨 mid
        if(end >= mid){
            right_node.update(start, end);
        }
    }
}

#+end_src
**** 线段树模板

#+INCLUDE: ./segment_tree.cpp src cpp

**** 加乘线段树模板

#+INCLUDE: ./segment_tree_with_plus_multi.cpp src cpp

*** ST 表
讲解： [[https://www.cnblogs.com/zwfymqz/p/8581995.html][浅谈 ST 表 - 自为风月马前卒]]：
解决静态 RMQ(Range Minimum/Maximum Query, 区间最值查询) 问题的数据结构

+ 线段树: 预处理 $O(n\log n)$, 单词询问 $O(\log n)$ ，空间 $O(n)$
+ ST 表: 预处理 $O(n)$, 单词询问 $O(1)$ ，空间 $O(n\log n)$

  模板读入方式： =std::cin >> st.access(i,0)= , $i \in [1,len]$

  *读入完成后需要执行=st.update()=来构建 ST 表*



#+INCLUDE: ./sparse_table.cpp src cpp

+关于刚写出来的这个模板有 bug 也能过洛谷模板题这件事+
** 数学
*** mod
出题人为了减少难度而让输出模一个数的结果

加法, 减法，乘法对取模的运算顺序和结果都无影响，但要注意要先算加或成

要
#+begin_src cpp
ans+= value;
ans%= modd;
#+end_src
不要
#+begin_src cpp
ans+= value%modd;
#+end_src

*会 WA 的* [[https://www.luogu.com.cn/record/69237315][40]]->[[https://www.luogu.com.cn/record/69237350][100]]

\begin{equation}
\begin{aligned}
(a+b) \% p &= (a \% p+b \% p) \% p \\
(a-b) \% p &= (a \% p-b \% p) \% p \\
(a*b) \% p &= (a \% p*b \% p) \% p \\
(a/b) \% p &= (a \% p/b \% p) \% p \text{错！}
\end{aligned}
\end{equation}

*** GCD
*后来我才知道 gcc 中的 algorithm 头提供了 =__gcd()= 函数*
**** 更相减损法

#+begin_src cpp :results output :exports both
int gcd(int a,int b)
{
    if(a==b)
        return a;
    if(a>b)
        return gcd(a-b,b);
    if(a<b)
        return gcd(b-a,a);
}

#include <iostream>
int main(){
    std::cout << gcd(6,9);
}
#+end_src

#+RESULTS:
: 3
**** 辗转相除法

#+begin_src cpp :results output :exports both
int gcd(int x, int y) { return y ? gcd(y, x % y) : x; }

#include <iostream>
int main(){
    std::cout << gcd(6,9);
}
#+end_src

#+RESULTS:
: 3

*** LCM

$lcm(a,b) = \frac{a \cdot b}{gcd(a,b)}$

#+begin_src cpp :results output :exports both
int gcd(int x, int y) { return y ? gcd(y, x % y) : x; }
int lcm(int a, int b) { return (a*b) / gcd(a,b); }

#include<iostream>
int main(){
    std::cout << lcm(6,9);
}
#+end_src

#+RESULTS:
: 18

*** 数字根

一个数字的数字根是指：将该数字各数位上的数字相加得到一个新的数，直到得到的数字小于 101010 为止，例如，149149149 的数字根为 149=>1+4+9=14=>1+4=5149 => 1+4+9=14 => 1+4=5 149=>1+4+9=14=>1+4=5，故 149149149 的数字根为 5。我们约定，小于 101010 的数字，其数字根就为其本身

一个数 $mod  9$ 就是他的数字根，特别的，如果模 9 得 0,那么数字根为 9

*** 费马小定理
如果 a 是一个整数，p 是一个质数
+ 当 a 是 p 的倍数，$a^p \equiv a (mod \space p)$
+ 当 a 不是 p 的倍数，$a^{p-1} \equiv 1 (mod p)$

*** 中位数切分

[[https://ac.nowcoder.com/acm/contest/23106/F][中位数切分]]

记数列中 $\ge m$ 的为 $cnt_1$, $< m$ 的为 $cnt_2$ 。

$f(l,r)$ 为数列中 $a_l \cdots a_r$ 范围内 $cnt_2 - cnt_1$ 的值

存在性质：
+ 当 $f(l,r) > 0$ 时，该范围中的中位数 $\ge m$
+ $f(l,r) = f(l,mid) + f(mid+1, r)$

#+INCLUDE: ../oj/coder/23106/F.cpp src cpp

** DP
*** 组合数 DP

[[https://ac.nowcoder.com/acm/contest/23106/A][九小时九个人九扇门]]

#+INCLUDE: ../oj/coder/23106/A.cpp src cpp

** 母函数
求组合数


解释没有，只有板子
#+begin_src cpp
#include<iostream>
const int lmax = 1e4;
int c1[lmax+1],c2[lmax+2];

int main(){
    int n,i,j,k;
    while(std::cin >> n){
        for(i = 0; i < n;i+=){
            c1[i] = 0;
            c2[i] = 0;
        }

        for(i = 0; i < n;i+=){
            c1[i] = 1;
        }

        for(i = 2; i <= n; i++){
            for(j = 0; j <= n;j++){
                for(k = 0;k + j<=n;k+=i){
                    c2[j+k] += c1[j];
                    for(j = 0; j <= n; j++){
                        c1[j] = c2[j];
                        c2[j]  = 0;
                    }
                }
            }
        }
        std::cout <<c1[n] << std::endl;
    }
    return 0;
}
#+end_src

*** 指数型母函数
用来求排列数
[[../template/figure/指数型母函数的定义.png]]

** 逆元

求取 $\frac{a}{b} \% p=a*(b\text{的逆元} \% p)$

$a$ 存在模 $p$ 的乘法逆元， *充要条件* 是 $gcd(a,p)=1$ ，既 $a$ 与 $p$ 互质



*** 应用[[*费马小定理][费马小定理]]（p 为质数）


$a \cdot x \equiv 1 (mod p)$ 其中 a 的逆元 x $= a^{p-2} \% p$

p 一般很大，要用快速幂

#+begin_src cpp
#include<cmath>
template<typename T> T inv_elem(T a,T p){
    return std::pow(a,p-2) % p;
}
#+end_src

** 金典
*** 组合数
**** 牛牛看云

[[https://ac.nowcoder.com/acm/contest/23106/H][牛客网-牛牛看云]]

#+INCLUDE: ../oj/coder/23106/H.cpp src cpp
