#+OPTIONS: _:nil
#+TITLE: Cheat Engine 中脚本编写

* AOB Array-of-bytes
可以采用这种方式来扫描指令中的位置。
使用 AOB, 首先要先找到指令的位置，复制指令到内存扫描器中，类型选择 =Array of bytes= 。因为指令段理论上不可写，所以应该取消掉 =Writable= 的 Checkbox （变为方块图标）。

众所周知，X86 指令前面的 1 到 3 字节是操作类型，后面则是数据，
在版本更新时，操作类型基本上是稳定的，但是数据这部分可能发生变化。
为了保险起见，执行 AOB 扫描时，建议只使用操作类型作为扫描依据，数据部分只要长度一样即可。

要做到这一点，只需要在扫描条件中，把不需要完全匹配的地方改为 =x= 即可。

* 编写脚本
一般情况下，我们只需要改变模板即可。

额外注意， CE 默认使用 16 进制数字，10 进制数字请用 =$= 开头，例如 =$5000=

一般不要修改 =return:= 标签下的内容，除非你知道你在做什么。

使用不同的模板，修改 =[Enable]= 和 =[Disable]=

** 可能用到的 CE 指令
+ alloc(label, size) :: 在程序栈内存末创建 =size= 大小的新内存区域，并标记为标签 =label= ，此操作会自动声明标签。
+ label(label) :: 声明标签
+ registerSymbol(label) :: 注册全局标签。默认情况下声明的标签只能只能在脚本中使用，其他地方不可访问。使用此命令可将标签标记的某块内存暴露给全局。

** 可能用到的汇编指令
标签可以作为内存地址使用。
+ mov dst, src :: 将 src 中的内容移动到 dst 中。注意每个语句中只能有一个设计内存的访存语句，即 =mov [ebx] [rcx]= 非法。
+ sub dst, src :: $dst = dst - src$
+ add dst, src :: $dst = dst + src$
+ jmp addr :: 将程序跳转到某个内存位置，该内存位置不需要加 =[]= 符号（因为不是访问）。
+ dd const_value :: 创建 4 字节内存区域，将 =const_value= 放入其中
+ cmp dst src :: 比较指令，按照 $dst-src$ 结果执行某行操作
  + pushfq/pushfd :: 压 eflags 寄存器栈帧（cmp 对该寄存器有影响）
  + popfq/popfd :: 弹出 eflags 寄存器栈帧（cmp 对该寄存器有影响）
  + je addr :: =cmp= 等于时跳转
  + jne addr :: =cmp= 不等于时跳转
