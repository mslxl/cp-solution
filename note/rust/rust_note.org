* Hello World
#+BEGIN_SRC rust
fn main(){
    print!("hello")
}

#+END_SRC

#+RESULTS:
: hello

* 变量

rust 中变量默认不可变，需要前置 =mut= 来让其可变。

#+BEGIN_SRC rust
fn main(){
    let _immutable = 2;

    let mut v = 2;
    println!("{}", v);
    v = 10;
    println!("{}", v);
}
#+END_SRC

#+RESULTS:
: 2
: 10

* 基本数据类型
** int
| Size                | Signed | Unsigned |
| 8 bit               | i8     | u8       |
| 16 bit              | i16    | u16      |
| 32 bit              |        |          |
| 64 bit              |        |          |
| 128 bit             |        |          |
| arch (系统架构有关) | isize  | usize    |

int 会被自动推断为 i32
#+BEGIN_SRC rust
fn main(){
    let a = 32;
    let b: i64 = 64;

    let f: f64 = 64.0;
}
#+END_SRC
** float
| Size   | Float |
| 32 bit | f32   |
| 64 bit | f64   |
** bool
** char
#+BEGIN_SRC rust
let a = 'a';
let smile = '\u{1F601}'
#+END_SRC
** &str
不可变的 string
#+BEGIN_SRC rust
let cat: &str = "car";
#+END_SRC

* 控制流
** if
注意：不像 java ，这里的条件语句并不需要括号
#+begin_src rust
fn main(){
    let num: i32 = 0;
    if num < 10 {
        println!("num less than 10");
    } else {
        println!("num bigger than 10");
    }
}
#+end_src

#+RESULTS:
: num less than 10

** for
** while
#+begin_src rust
fn main(){
    let mut i:i32 = 0;
    while i < 10 {
        println!("i = {}", i);
        i+=1;
    }
}
#+end_src

#+RESULTS:
#+begin_example
i = 0
i = 1
i = 2
i = 3
i = 4
i = 5
i = 6
i = 7
i = 8
i = 9
#+end_example

** loop
无限循环，只能通过 break 中断
#+begin_src rust
fn main(){
    let mut i = 0;
    loop {
        i+=1;
        if i == 5 {
            continue;
        } else if i == 10 {
            break;
        }
        println!("i = {}",i);

    }
}

#+end_src

#+RESULTS:
: i = 1
: i = 2
: i = 3
: i = 4
: i = 6
: i = 7
: i = 8
: i = 9

** match
类似 scala 的模式匹配，但是必须写出所有可能条件。
#+begin_src rust
fn main(){
    let num = 9;
    // 不是 num match{...}
    match num {
        2 => println!("it's 2"),
        5..=9 => println!("between 5 and 9"),
        _ => println!("unkown"),
    }
}
#+end_src

注意在每个分支的语句之间用 =,= 隔开
#+RESULTS:
: between 5 and 9

* 函数
最后一行不加 ; 自动作为返回值返回
** 普通函数
声明形式： =fn function(a:i32, b:i32) -> i32=
#+begin_src rust
fn add_func(a:i32, b:i32) -> i32 {
    a+b
}

fn main() {
    print!("{}", add_func(1,2));
}

#+end_src

#+RESULTS:
: 3

** 匿名表达式（闭包， lambda)
#+begin_src rust
fn main(){
    let f = |a:i32, b:i32| -> i32 {
        a+b
    };
    println!("{}",f(2,4));
}

#+end_src

* 复合类型声明
** 枚举 (Enum)
*** 内置枚举类型
+ Result
+ Option
  Rust 没有 None( 为了类型安全，所以需要使用 Option 进行包装)

*** 自设
#+begin_src rust
// 导出类型以供打印
#[derive(Debug)]

enum Pos{
    L,
    R
}

fn main(){
    let mut pos:Pos = Pos::L;
    println!("{:?}",pos); // 复合类型打印需要 [:?]

    pos = Pos::R;
    match pos {
        Pos:: L => println!("L"),
        Pos:: R => println!("R")
    }
}

#+end_src

#+RESULTS:
: L
: R

** 结构体 (Struct)
#+begin_src rust

#[derive(Debug)]
struct Rect{
    w:i32,
    h:i32
}

fn main() {
    let r = Rect{
        w:3,
        h:4
    };
    println!("{}",r.w);
    println!("{:?}",r);
}
#+end_src

#+RESULTS:
: 3
: Rect { w: 3, h: 4 }

*** 关联函数
#+begin_src rust


#[derive(Debug)]
struct Rect{
    w:i32,
    h:i32
}
impl Rect {
    // 关联函数可以与实例无关
    fn area(w:i32, h:i32) -> i32{
        w * h
    }
    // 有关, 又称“实例方法”
    fn area2(&self) -> i32 {
        self.w * self.h
    }
}

fn main() {
    let r = Rect{
        w:3,
        h:4
    };
    println!("{}",Rect::area(4,6));
    println!("{}",r.area2());
}

#+end_src

#+RESULTS:
: 24
: 12

*** 构造函数

#+begin_src rust

#[derive(Debug)]
struct Rect{
    w:i32,
    h:i32
}
impl Rect{
    // pub 即 public
    pub fn new(width:i32,height:i32) -> Self {
        Rect{
            w:width,
            h:height
        }
    }
}

fn main() {
    let r = Rect::new(3,4);
    println!("{:#?}",r);
}
#+end_src

#+RESULTS:
: Rect {
:     w: 3,
:     h: 4,
: }
*** self, &self 与 &mut self


#+begin_src rust

#[derive(Debug)]

struct Person {
    name:String,
    age:i16
}
impl Person {
    // 相当与 this 指针，但是它不可变
    fn greet(&self) -> String {
        format!("Hi {}!",self.name)
    }

    // 相当与 this 指针，可变
    fn up_age(&mut self, n:i16){
        self.age += n
    }
    // self 会转移所有权，在函数结束后会被销毁
    fn drop(self) {
        println!("{} dropped",self.name);
    }
}

fn main() {
    let xiaoMing = Person{
        name: "Xiao Ming".to_string(),
        age: 18
    };
    println!("{}", xiaoMing.greet());

    let mut hua = Person {
        name: "Xiao Hua".to_string(),
        age: 18
    };
    println!("{:?}",hua);
    hua.up_age(1); // 调用此方法要求 hua 被 mut 修饰，即变量为可变类型
    println!("{:?}",hua);
    hua.drop();
    // println!("{:?}",hua); // 会报错
}
#+end_src

#+RESULTS:
: Hi Xiao Ming!
: Person { name: "Xiao Hua", age: 18 }
: Person { name: "Xiao Hua", age: 19 }
: Xiao Hua dropped
** 元组 (Tuples)
类型类型有数组，切片，但在 rust 中不常用，常用 Vector
元组具有以下特征：
+ 匿名储存数据
+ 不可变

*** 使用
#+begin_src rust

fn oneTwoThree() -> (i32,i32,i32) {
    (1,2,3)
}

fn main() {
    let tuple = oneTwoThree();
    println!("{:?}",tuple);
    // 提取元素
    let (x,_,y) = tuple;
    println!("x={}, y={}",x,y);
}
#+end_src

#+RESULTS:
: (1, 2, 3)
: x=1, y=3

* OwnerShip
** 原则
+ 每个值都有一个变量称为所有者
+ 每个值同时只能有一个所有者
+ 当所有者超出作用域时，值被销毁
*** Stack 和 Heap
+ Stack 储存已知大小的数据块，基础数据类型等
+ Heap 储存未知大小的数据，Struct 等，速度慢
** move
堆上先浅拷贝，再把原来的值销毁
#+begin_src rust
let a = "ff".to_string();
let b = a; // a 失效
#+end_src
例如：
#+begin_src rust
fn main() {
    let a = "str".to_string();
    let b = a;
    println!("a={}, b={}",a,b);
}
#+end_src

#+begin_src
error[E0382]: borrow of moved value: `a`
 --> src/main.rs:5:27
  |
3 |     let a = "str".to_string();
  |         - move occurs because `a` has type `String`, which does not implement the `Copy` trait
4 |     let b = a;
  |             - value moved here
5 |     println!("a={}, b={}",a,b);
  |                           ^ value borrowed here after move
#+end_src

** clone
栈上的内容执行深拷贝
深拷贝，会开辟新的空间

#+begin_src rust
fn main() {
    let a = "str";
    let b = a;
    println!("a={}, b={}",a,b);
}
#+end_src

#+RESULTS:
: a=str, b=str
** Reference
+ 通过 & 可以获得值的引用
+ 未获得值的所有权，在作用域结束后不会被销毁
+ 这种情况叫借用 borrowed
#+begin_src rust
fn main() {
    let a = "str".to_string();
    let b = &a;
    println!("a={}, b={}",a,b);
}
#+end_src

#+RESULTS:
: a=str, b=str

#+begin_src rust
#[derive(Debug)]
struct A {
    v:i32,
}
// 不可变
fn print_v(a:&A){
    println!("{}",a.v);
}
// 可变，要求变量被 mut 修饰
fn up_v(a:&mut A){
    a.v*=2
}

fn main() {
    let a = A{
        v:32
    };
    print_v(&a);
    println!("{:?}",a);

    let mut mutA = A{
        v:32
    };

    println!("before {:?}",mutA);
    up_v(&mut mutA);
    println!("after {:?}",mutA);

}

#+end_src

#+RESULTS:
: 32
: A { v: 32 }
: before A { v: 32 }
: after A { v: 64 }

注意：在同一作用域下，对某一块数据：
+ 可以有多个不可变的引用
+ 只能有一个可变的引用
+ 不能同时拥有一个可变引用和不可变引用
** Copy && Clone
#+begin_src rust
// 需要实现 Clone, 之后才可使用 obj.clone()
#[derive(Debug, Clone)]

struct Person {
    name:String,
    age:i32
}
fn main() {
    let man = Person {
        name:"Ming".to_string(),
        age:18
    };
    let oth = man; // 这是 move, man 之后会失效
    let mut man = oth.clone();
    println!("{:?}", oth);
    man.age+=1;
    println!("{:?}", man);
}

#+end_src

#+RESULTS:
: Person { name: "Ming", age: 18 }
: Person { name: "Ming", age: 19 }

#+begin_src rust
// 如果还想扔到栈上, 还需要实现 Copy
#[derive(Debug, Clone, Copy)]
// Copy 需要长度固定，而 String 明显是长度可变的，所以换为 &str

// <'a> 和 'a 用来标注生命周期，意为 name 的生命周期与 Person 的生命周期一致
struct Person<'a> {
    name:&'a str,
    age:i32
}
fn main() {
    let man = Person {
        name:"Ming",
        age:18
    };
    let oth = man; // 这是 move, man 之后会失效
    println!("{:?}", man);
    println!("{:?}", oth);
}

#+end_src

#+RESULTS:
: Person { name: "Ming", age: 18 }
: Person { name: "Ming", age: 18 }
*** Lifetime
+ 避免 dangling reference
+ rust 中所有的引用都有自己的生命周期，表示引用有效的作用域
+ 一般为隐式的，但不可推断时会报错，需要手动标注
  - =fn longest(a:&str, b:&str) -> &str=
  - 生命周期最短为有效
  - 尽量不要使用 =static=
  - 省略规则：
    + 每个引用类型的参数都有自己的生命周期
    + 只有一个输入生命周期参数，那么输出生命周期就为该生命周期
    + 有 =&self= 或 =&mut self=, 那么输出生命周期就为该 self 生命周期

* 常见类型
** String
*** &str: String slices 不可变的
#+begin_src rust
let cat = "cat";
#+end_src
*** String objects
#+begin_src rust
let dog = String::new();
let dog = String::format("");
let dog = "s".to_string();
#+end_src
或者通过 =format!= 生成
*** String method
#+begin_src rust
fn main() {
    let str = String::from("sss");
    println!("{} 'len is {}", str,str.len());
}
#+end_src

#+RESULTS:
: sss 'len is 3

#+begin_src rust
fn main() {
    let mut str = String::from("sss");
    println!("Before: {}",str);
    str.push('j');
    println!("After push: {}",str);
    str.push_str("www");
    println!("After push_str: {}",str);
    str = str.replace("sjw",".");
    println!("After replace: {}",str);
}
#+end_src

#+RESULTS:
: Before: sss
: After push: sssj
: After push_str: sssjwww
: After replace: ss.ww

** Vector

*** new
#+begin_src rust
let arr = Vec::new();
let arr = vec![1,2];
let arr = vec![1;20];
#+end_src

*** push && remove
#+begin_src rust
fn main() {
    let mut vec:Vec<i32> = Vec::new();
    vec.push(1);
    println!("{:?}",vec);
    vec.remove(0);
    println!("{:?}",vec);

}
#+end_src

#+RESULTS:
: [1]
: []

*** update && access
#+begin_src rust
fn main() {
    let arr = vec![1;20];
    println!("{:?}",arr);
    println!("{}",arr[19]);
    println!("{:?}",arr.get(19));
    println!("{:?}",arr.get(20));
    match arr.get(20){
        Some(item) => println!("some -> {}",item),
        None =>println!("arr.get(20) return None")
    }
}
#+end_src

#+RESULTS:
: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
: 1
: Some(1)
: None
: arr.get(20) return None

*** Iter
#+begin_src rust
fn main() {
    let arr = vec![1;20];
        print!("|");
    for item in arr.iter(){
        print!("{}|", item);
    }
}
#+end_src

#+RESULTS:
: |1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|1|

** HashMap

*** 组成
HashMap 由链表+数组组成，底层结构是一个数组，而数据的元素是一个单向链表

#+BEGIN_SRC dot :file test_graphviz.png
digraph hashmap{
    node [shape=record];
    array [label="<f0>0|<f1>1|<f2>2|<f3>3|<f4>4|<f5>5|<f6>..."];
    n0[label="..."];
    n1[label="..."];
    n2[label="..."];
    n3[label="..."];
    n4[label="..."];
    n5[label="..."];
    array:f0 -> 496 -> 896 -> n0;
    array:f1 -> 1 -> 337 -> 353 -> n1;
    array:f2 -> n2;
    array:f3 -> 387 -> n3;
    array:f4 -> n4;
    array:f5 -> n5;
}
#+end_src


#+begin_src rust
use std::collections::HashMap;
fn main() {
    let mut str_map = HashMap::new();
    str_map.insert("l",2);
    str_map.insert("t",44);
    println!("{:#?}",str_map);
    match str_map.get("l"){
        Some(item)=>println!("{}",item),
        _=>println!("None")
    }

    str_map.remove("l");
    for i in str_map.into_iter(){
        println!("{:?}",i);
        println!("{},{}",i.0,i.1);
    }
}

#+end_src

#+RESULTS:
: {
:     "l": 2,
:     "t": 44,
: }
: 2
: ("t", 44)
: t,44
* Traits
+ 与接口和抽象类类似
+ 给结构体添加定义的行为
  #+begin_src rust
trait Person{
    fn new(awesome:String) -> Self;
    fn language(&self) -> &str;
    fn say(&self){
        println!("hello");
    }
}
struct A{
    name:String
}
impl Person for A{
    fn new(awesome:String) -> Self{
        A{
            name:awesome
        }
    }
    fn language(&self) -> &str{
        "A's lang"
    }
    fn say(&self){
        println!("hi");
    }
}
fn main() {
    let a = A::new(String::from("han"));
    println!("{}",a.language());
    a.say();
}

  #+end_src

  #+RESULTS:
  #+begin_example
  warning: field is never read: `name`
    --> src/main.rs:10:5
     |
  10 |     name:String
     |     ^^^^^^^^^^^
     |
     = note: `#[warn(dead_code)]` on by default

  warning: 1 warning emitted

  warning: field is never read: `name`
    --> src/main.rs:10:5
     |
  10 |     name:String
     |     ^^^^^^^^^^^
     |
     = note: `#[warn(dead_code)]` on by default

  warning: 1 warning emitted

  A's lang
  hi
  #+end_example
* 泛型
#+begin_src rust
trait Barkable{
    fn bark(&self);
}

struct Cat {
    name:String
}

struct Dog {
    owner:String
}
impl Barkable for Cat{
    fn bark(&self){
        println!("Meow~")
    }
}
impl Barkable for Dog{
    fn bark(&self){
        println!("Woof!")
    }
}
impl Cat {
    fn climb(&self){
        println!("{} is climbing", self.name);
    }
    fn new(name:&str)->Self{
        Cat{
            name:name.to_string()
        }
    }
}
impl Dog {
    fn run(&self){
        println!("{}'s dog is running", self.owner);
    }
    fn new(owner:&str)->Self{
        Dog{
            owner:owner.to_string()
        }
    }
}

fn imitate <T:Barkable>(obj:T){
    print!("The imitation of ");
    obj.bark();
}
fn main() {
    let dog = Dog::new("XiaoMing");
    let cat = Cat::new("Hua");
    dog.bark();
    dog.run();
    cat.bark();
    cat.climb();
    imitate(dog);
    imitate(cat);
}
#+end_src

#+RESULTS:
: Woof!
: XiaoMing's dog is running
: Meow~
: Hua is climbing
: The imitation of Woof!
: The imitation of Meow~
