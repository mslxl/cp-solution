#+TITLE:  Lua

* Varibable
** Number
All number are doubles

64 bit doubles have *52 bits for storing exact int values*,
so it is not a problem for ints that need less that 52 bits

#+begin_src lua :results output
num = 3
precision = 3.14
print(num, precision)
#+end_src

#+RESULTS:
: 3	3.14

** string
#+begin_src lua :results output
singleLine = 'hello'
doubleQuote = "world"
multiLine = [[
What do you do at the end of the world?
Are you busy?
Will you save us?
]]
print(multiLine)
#+end_src

#+RESULTS:
: What do you do at the end of the world?
: Are you busy?
: Will you save us?
:
The last line of string's multi-line declare have a \n
Remember to adjust the position of =]]=

#+begin_src lua :results output
multiLine = [[
Will you save us?]]
print(multiLine)
#+end_src

#+RESULTS:
: Will you save us?


** boolean
#+begin_src lua :results output
aBoolean = true
#+end_src

#+RESULTS:

* Operator
** euqal and not equal
#+begin_src lua :results output
var1 = 1
var2 = 3
print(var1 == var2)
print(var1 ~= var2)
#+end_src

#+RESULTS:
: false
: true

** less and greater
#+begin_src lua :results output
print(1 < 50)
print(20 > 30)
print(20 >= 20)
#+end_src

#+RESULTS:
: true
: false
: true

** =and= and =or=
#+begin_src lua :results output
print(true and true)
print(true and false)

print(true or false)
#+end_src

#+RESULTS:
: true
: false
: true

** =not=
#+begin_src lua :results output
print(not true)
#+end_src

#+RESULTS:
: false

* Flow contorl
** Branch
*** Simple
#+begin_src lua :results output
num = 50
if num > 40 then
  print(num, "bigger than 40")
end
#+end_src

#+RESULTS:
: 50	bigger than 50

*** Else if

#+begin_src lua :results output
num = 50
if num < 40 then
  print("num < 40")
elseif num ~= 50 then
  print("num ~= 50")
else
  print("num = ", num)
end
#+end_src

#+RESULTS:
: num = 	50

** Loop
*** while
#+begin_src lua :results output
num = 0
while num < 15 do
  num = num + 1
  print(num)
end
#+end_src

#+RESULTS:
#+begin_example
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
#+end_example

*** for range
#+begin_src lua :results output
for i = 1, 10 do -- Strage grammer
  print(i)
end
#+end_src

#+RESULTS:
#+begin_example
1
2
3
4
5
6
7
8
9
10
#+end_example

*** repeat

#+begin_src lua :results output
num = 10
repeat
  print(num)
  num = num - 1
until num == 0
#+end_src

#+RESULTS:
#+begin_example
10
9
8
7
6
5
4
3
2
1
#+end_example

* Function
*** Common expr
#+begin_src lua :results output
function fib(n)
  if n <= 2 then return 1 end
  return fib(n-2) + fib(n-1)
end

for i = 1,5 do
  print(fib(i))
end
#+end_src

#+RESULTS:
: 1
: 1
: 2
: 3
: 5

*** Closures and anonymous
#+begin_src lua :results output

function plus(x)
  return function(y)
    return x + y
  end
end

print(plus(1)(2))
#+end_src

#+RESULTS:
: 3

*** Unbox
Like python, lua also support unbox return value
#+begin_src lua :results output
function aaa()
  return 1,2,3,4,5,6
end
print(aaa())
a,b,c,d,e,f = aaa()
print(a,a,d,e,a,d)
#+end_src

#+RESULTS:
: 1	2	3	4	5	6
: 1	1	4	5	1	4

*** Lambda
#+begin_src lua :results output
f = function(x) return x end
print(f(1))
#+end_src

#+RESULTS:
: 1

*** Local
#+begin_src lua :results output
local function g(x) return math.sin(x) end
local g; g  = function (x) return math.sin(x) end
print(g(0))
#+end_src

#+RESULTS:
: 0.0

* Dict
#+begin_src lua :results output
dict = {
  key1 = 'v',
  key2 = false
}
print(dict.key1)
dict.key2 = nil
#+end_src

#+RESULTS:
: v
